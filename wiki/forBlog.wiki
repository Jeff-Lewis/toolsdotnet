== On extending Silverlight Unit Test harness ==

published: http://plainoldstan.blogspot.com/2010/06/extending-silverlight-unit-testing.html

== On using partial class to isolate silverlight wcf client to its interface ==
{{{
        public SiteSettingsContext(CommonServiceClient client) : this()
        {
            if ( client == null ) throw new ArgumentNullException("client");
            _client = client;
        }

    public interface ITerminologyService
    {
        event System.EventHandler<GetTerminologyListCompletedEventArgs> GetTerminologyListCompleted;
        void GetTerminologyListAsync();
    }

public partial class CommonServiceClient : ITerminologyService

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(ConfigurationName="CommonService.ICommonService")]
    public interface ICommonService {
        
        [System.ServiceModel.OperationContractAttribute(AsyncPattern=true, Action="http://tempuri.org/ITerminologyProvider/GetTerminologyList", ReplyAction="http://tempuri.org/ITerminologyProvider/GetTerminologyListResponse")]
        System.IAsyncResult BeginGetTerminologyList(System.AsyncCallback callback, object asyncState);
        
        System.Collections.ObjectModel.ObservableCollection<Valtera.WcfServices.Client.CommonService.Terminology> EndGetTerminologyList(System.IAsyncResult result);


private ITerminologyService _client = new CommonServiceClient();

        public SiteSettingsContext(ITerminologyService client)
            : this()
        {
            if ( client == null ) throw new ArgumentNullException("client");
            _client = client;
        }

}}}

== On using Moq with/for events ==
{{{

protected override void TestInitialize()
        {
            base.TestInitialize();
            _terminologyService = AutoMockRegistrator.CreateDynaMockFor<ITerminologyService>();

            _context = IoC.Resolve<SiteSettingsContext>();
        }

        [TestMethod]
        [ExpectedException(typeof(InvalidOperationException))]
        public void Should_ThrowWhenUsedAndNotLoadedYet()
        {
            var context = new SiteSettingsContext(_terminologyService.Object);
            var terminologies = context.GetTerminologies();
        }
        [TestMethod]
        [Asynchronous]
        [Timeout(500)]
        public void Should_HaveTerminologiesAfterLoad()
        {
            var context = new SiteSettingsContext(new TerminologyServiceStub());

            context.LoadCompleted += ( s, e ) =>
            {
                AssertForFixedTerminologies(context.GetTerminologies());
                EnqueueTestComplete();
            };
            context.Load();
        }
        [TestMethod]
        [Asynchronous]
        [Timeout(500)]
        public void Should_HaveTerminologiesAfterLoadMoq()
        {
            _terminologyService.Setup(t => t.GetTerminologyListAsync()).Callback(()=>
            {
                _terminologyService.Raise(ts => ts.GetTerminologyListCompleted += null, new GetTerminologyListCompletedEventArgs(TerminologyFake.GetFixedActionPlanTerminology(), null,
false, null));
            });

            var context = new SiteSettingsContext(_terminologyService.Object);

            context.LoadCompleted += (s, e) =>
            {
                AssertForFixedTerminologies(context.GetTerminologies());
                EnqueueTestComplete();
            };
            context.Load();
        }


        internal class TerminologyServiceStub : ITerminologyService
        {
            public event EventHandler<GetTerminologyListCompletedEventArgs> GetTerminologyListCompleted;
            public void GetTerminologyListAsync()
            {
                // Verify that event has been subscribed to
                Assert.IsNotNull(GetTerminologyListCompleted);
                // Raise the event
                GetTerminologyListCompleted(this,
                    new GetTerminologyListCompletedEventArgs(TerminologyFake.GetFixedActionPlanTerminology(), null,
                        false, null));
            }
        }

}}}

== On logging from Silverlight to Browser console ==

{{{

        <script type="text/javascript">	
		function LogInfo(message) { if (((typeof(console) !== "undefined") && (typeof(console.log) !== "undefined"))) console.log("info:" + message);}
		function LogError(message) {	if (IsConsoleDefined()) console.error(message);}
		function LogFatal(message) {	if (IsConsoleDefined()) console.error(message);}
		function LogWarning(message) { if (IsConsoleDefined()) console.warn(message);}
		function LogDebug(message) { if (IsConsoleDefined()) console.log("debug:" + message);}		
		function IsConsoleDefined(){ return ((typeof(console) !== "undefined") && (typeof(console.log) !== "undefined"));}
	</script>

}}}

{{{

using System;
using System.Collections.Generic;
using System.Windows.Browser;


namespace Valtera.SilverlightShared.CommonInfrastructure.Logging
{
    public class BrowserConsoleLogger : ILocalLogger
	{
        public const string LOG_DEBUG_FUNCTION_NAME = "LogDebug";
        public const string LOG_ERROR_FUNCTION_NAME = "LogError";
        public const string LOG_FATAL_FUNCTION_NAME = "LogFatal";
        public const string LOG_INFO_FUNCTION_NAME = "LogInfo";
        public const string LOG_WARNING_FUNCTION_NAME = "LogInfo";

        private readonly List<string> _levelsForError = new List<string>{"debug", "info", "error", "warn"};
        private readonly List<string> _levelsForFatal = new List<string>{"debug", "info", "error", "warn", "fatal"};
        private readonly List<string> _levelsForInfo = new List<string> { "debug", "info" };
        private readonly List<string> _levelsForWarning = new List<string> { "debug", "info", "warn" };
		public void Debug( string message )
		{
		    string requestedLogLevel = null;
            HtmlPage.Document.QueryString.TryGetValue("log", out requestedLogLevel);

            if (requestedLogLevel != null && requestedLogLevel.ToLower() == "debug")
    		    HtmlPage.Window.Invoke(LOG_DEBUG_FUNCTION_NAME, message);
		}
		public void Error( string message, Exception ex )
		{
            string requestedLogLevel = null;
            HtmlPage.Document.QueryString.TryGetValue("log", out requestedLogLevel);

            if (requestedLogLevel != null && _levelsForError.Contains(requestedLogLevel.ToLower()))
                HtmlPage.Window.Invoke(LOG_ERROR_FUNCTION_NAME, String.Format("{0}. Exception text: {1}", message, ex));			
		}


		public void Fatal( string message, Exception ex )
		{
            string requestedLogLevel = null;
            HtmlPage.Document.QueryString.TryGetValue("log", out requestedLogLevel);

            if (requestedLogLevel != null && _levelsForFatal.Contains(requestedLogLevel.ToLower()))
            HtmlPage.Window.Invoke(LOG_FATAL_FUNCTION_NAME, String.Format("{0}. Exception text: {1}", message, ex));
		}

		public void Info( string message )
		{
            string requestedLogLevel = null;
            HtmlPage.Document.QueryString.TryGetValue("log", out requestedLogLevel);

            if (requestedLogLevel != null && _levelsForInfo.Contains(requestedLogLevel.ToLower()))
                HtmlPage.Window.Invoke(LOG_INFO_FUNCTION_NAME, message);				
		}

		public void Warning( string message )
		{
            string requestedLogLevel = null;
            HtmlPage.Document.QueryString.TryGetValue("log", out requestedLogLevel);

            if (requestedLogLevel != null && _levelsForWarning.Contains(requestedLogLevel.ToLower()))
                HtmlPage.Window.Invoke(LOG_WARNING_FUNCTION_NAME, message);				
		}
	}
}

}}}

== On TlbImp : error TI0000: Encountered multiple versions of the assembly with GUID ==
