#summary OOP and OOD cheat sheet

= Introduction =

Over the time I see interpretation of concepts and idioms to become quite overloaded.
I tend to forget subtlities of the definitions and yet I want to have them handy.
Disclaimer: The contents of the cheat sheet is built in the way to ring mine bells.

= Books =
* Fundamentals of object oriented design and UML* (Meilir Page-Jones)
http://www.amazon.com/Fundamentals-Object-Oriented-Design-Addison-Wesley-Technology/dp/020169946X 
_I put this book on top as I believe it gave me at the time the best overview of OO principles. I used to be based on Booch's and Bertrand Meyer's books, but this one was a breath of a fresh air, trully._ 

* Object Oriented Analisys and Desing with Applications* (Grady Booch)
http://www.amazon.com/Object-Oriented-Analysis-Applications-Addison-Wesley-Technology/dp/020189551X/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218393901&sr=1-1

* Object Oriented Software Construction* (Bertrand Meyer) 
http://www.amazon.com/Object-Oriented-Software-Construction-Prentice-Hall-International/dp/0136291554/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394084&sr=1-1 

*Agile Principles, Patterns and Practices in C#* (Robert C. Martin)
http://www.amazon.com/Principles-Patterns-Practices-Robert-Martin/dp/0131857258/ref=pd_bbs_sr_3?ie=UTF8&s=books&qid=1218394574&sr=1-3

*Applying UML and Patterns* (Graig Larman)
http://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394650&sr=1-1

*Design patterns* (Erich Gamma)
http://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional/dp/0201633612/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394843&sr=1-1

*Patterns oriented software architecture* (Douglas Schmidt) 
http://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697/ref=sr_1_1?ie=UTF8&s=books&qid=1218394916&sr=1-1
http://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952/ref=pd_bxgy_b_text_b

= Concepts =

= Most important concepts of OO =
As provided by Page Mielier Jones
(TBD)


= Principles = 

== The Single Responsibility Principle ==

== The Open/Closed Principle ==

== The Liskov Substitution principle ==
[http://www.objectmentor.com/resources/articles/lsp.pdf Objectmentor:] FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.

The above is a paraphrase of the Liskov Substitution Principle (LSP). Barbara Liskov first
wrote it as follows nearly 8 years ago 
1:What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o
1 is substituted for o2 then S is a subtype of T.



== The Dependency Inversion Principle ==
A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.

B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS.

[http://www.objectmentor.com/resources/articles/dip.pdf Original Article]

== The Interface Segregation Principle ==

[http://www.objectmentor.com/resources/articles/isp.pdf Objectmentor]: 

CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.

= Idioms =

= Methods/Approaches =

== Dependency Injection (Inversion of control) ==

_Between points to note is that application of dependency inversion preceeds very often dependency injection, preparing the right ground for dependency injection application._

== Assigning responsibilities ==
=== Creator ===
=== Knowledge Expert ===
=== Pure fabrication ===

== Design for testability ==

== Design/Programming by contract ==
*Not to be interchanged with the "Contract First Design"* _Read [http://static.springframework.org/spring-ws/sites/1.5/reference/html/why-contract-first.html here] on the "Contract First" _

An approach to designing computer software. It prescribes that software designers should define precise verifiable interface specifications for software components based upon the theory of abstract data types and the conceptual metaphor of a business contract.

One could summarize design by contract by the "three questions" that the designer must repeatedly ask:

What does it expect? 
What does it guarantee? 
What does it maintain? 

The notion of a contract extends down to the method/procedure level; the contract for each method will normally contain the following pieces of information:

* Acceptable and unacceptable input values or types, and their meanings 
* Return values or types, and their meanings 
* Error and exception conditions values or types, that can occur, and their meanings 
* Side effects 
* Preconditions, which subclasses may weaken (but not strengthen) 
* Postconditions, which subclasses may strengthen (but not weaken) 
* Invariants, which subclasses may strengthen (but not weaken) 
* (more rarely) Performance guarantees, e.g. for time or space used 

Source - Wikipedia: [http://en.wikipedia.org/wiki/Design_by_contract]  