#summary OOP cheatsheet
#labels oop

= Introduction =

Over time I see interpretation of concepts and idioms to become quite overloaded.
I tend to forget subtlities of the definitions and yet I want to have them handy.
Disclaimer: The contents of the cheat sheet is built in the way to ring mine bells, yours might need a different frequency :).

= Books =
* Fundamentals of object oriented design and UML* (Meilir Page-Jones)
http://www.amazon.com/Fundamentals-Object-Oriented-Design-Addison-Wesley-Technology/dp/020169946X 
_I put this book on top as I believe it gave me at the time the best overview of OO principles. I used to be based on Booch's and Bertrand Meyer's books, but this one was a breath of a fresh air, trully._ 

* Object Oriented Analisys and Desing with Applications* (Grady Booch)
http://www.amazon.com/Object-Oriented-Analysis-Applications-Addison-Wesley-Technology/dp/020189551X/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218393901&sr=1-1

* Object Oriented Software Construction* (Bertrand Meyer) 
http://www.amazon.com/Object-Oriented-Software-Construction-Prentice-Hall-International/dp/0136291554/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394084&sr=1-1 

*Agile Principles, Patterns and Practices in C#* (Robert C. Martin)
http://www.amazon.com/Principles-Patterns-Practices-Robert-Martin/dp/0131857258/ref=pd_bbs_sr_3?ie=UTF8&s=books&qid=1218394574&sr=1-3

*Applying UML and Patterns* (Graig Larman)
http://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394650&sr=1-1

*Design patterns* (Erich Gamma)
http://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional/dp/0201633612/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1218394843&sr=1-1

*Patterns oriented software architecture* (Douglas Schmidt) 
http://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697/ref=sr_1_1?ie=UTF8&s=books&qid=1218394916&sr=1-1
http://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952/ref=pd_bxgy_b_text_b

= Most important concepts of OO =
For this one I don't like [http://en.wikipedia.org/wiki/Object-oriented_programming Wikipedia's] definition at all. Meilir Page-Jones is my trusted reference source for this:

==Encapsulation==

==Polymorphism==

==Identity==

==Combining state and behaviour==


I believe that what is provided by [http://en.wikipedia.org/wiki/Object-oriented_programming Wikipedia] is quite a wild mix of concepts (class, object, instance), mechanisms (method, inheritance) and design principles (abstraction, decoupling) flushed onto one list.

= Principles = 

== The Single Responsibility Principle (SRP)==
[http://www.objectmentor.com/resources/articles/srp.pdf Objectmentor]:
THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE.

"... each responsibility is an axis of change. When the requirements change, that
change will be manifest through a change in responsibility amongst the classes. If a class
assumes more than one responsibility, then there will be more than one reason for it to
change.
If a class has more then one responsibility, then the responsibilities become coupled.
Changes to one responsibility may impair or inhibit the class’ ability to meet the others.
This kind of coupling leads to fragile designs that break in unexpected ways when
changed."

== The Open/Closed Principle (OCP)==
[http://www.objectmentor.com/resources/articles/ocp.pdf Objectmentor]:
SOFTWARE ENTITIES (CLASSES, MODULES, FUNCTIONS, ETC.) SHOULD BE OPEN FOR EXTENSION, BUT CLOSED FOR MODIFICATION.

"... When a single change to a program results in a cascade of changes to dependent modules,
that program exhibits the undesirable attributes that we have come to associate with “bad”
design. The program becomes fragile, rigid, unpredictable and unreusable. The openclosed
principle attacks this in a very straightforward way. It says that you should design
modules that never change. When requirements change, you extend the behavior of such
modules by adding new code, not by changing old code that already works."

== The Liskov Substitution principle (LSP)==
[http://www.objectmentor.com/resources/articles/lsp.pdf Objectmentor]: FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.

"... The above is a paraphrase of the Liskov Substitution Principle (LSP). Barbara Liskov first
wrote it as follows nearly 8 years ago 

_What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T._"

The classic example used in object mentor document is a rectangle and a square. One should be able to answer if square is a correct subtype of a rectangle or not (same can be ellipse and circle).

== The Dependency Inversion Principle ==
[http://www.objectmentor.com/resources/articles/dip.pdf Objectmentor]:
A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.

B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS.

== The Interface Segregation Principle ==

[http://www.objectmentor.com/resources/articles/isp.pdf Objectmentor]: 

CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.

= Idioms =

= Methods/Approaches =

== Dependency Injection (Inversion of control) ==

[http://martinfowler.com/articles/injection.html Martin Fowler]: _In the Java community there's been a rush of lightweight containers that help to assemble components from different projects into a cohesive application. Underlying these containers is a common pattern to how they perform the wiring, a concept they refer under the very generic name of "Inversion of Control". In this article I dig into how this pattern works, under the more specific name of "Dependency Injection", and contrast it with the Service Locator alternative. The choice between them is less important than the principle of separating configuration from use._

Between points to note is that application of dependency inversion preceeds very often dependency injection, preparing the right ground for dependency injection application.

== Assigning responsibilities ==
=== Creator ===
=== Knowledge Expert ===
=== Pure fabrication ===

== Design for testability ==

== Design/Programming by contract ==
*Not to be interchanged with the "Contract First Design"* _Read [http://static.springframework.org/spring-ws/sites/1.5/reference/html/why-contract-first.html here] on the "Contract First" _

An approach to designing computer software. It prescribes that software designers should define precise verifiable interface specifications for software components based upon the theory of abstract data types and the conceptual metaphor of a business contract.

One could summarize design by contract by the "three questions" that the designer must repeatedly ask:

What does it expect? 
What does it guarantee? 
What does it maintain? 

The notion of a contract extends down to the method/procedure level; the contract for each method will normally contain the following pieces of information:

* Acceptable and unacceptable input values or types, and their meanings 
* Return values or types, and their meanings 
* Error and exception conditions values or types, that can occur, and their meanings 
* Side effects 
* Preconditions, which subclasses may weaken (but not strengthen) 
* Postconditions, which subclasses may strengthen (but not weaken) 
* Invariants, which subclasses may strengthen (but not weaken) 
* (more rarely) Performance guarantees, e.g. for time or space used 

Source - [http://en.wikipedia.org/wiki/Design_by_contract Wikipedia]  

= Jargon and terms =
For the full list of terms refer to [http://en.wikipedia.org/wiki/List_of_object-oriented_programming_terms Wikipedia]. I only provide here "jargon" terms that are used quite often in the community.

A helper to remember at this stage would be KYD (K[iss] Y[agni] D[ry]).

==KISS==
"Keep It Simple, Stupid!" [http://en.wikipedia.org/wiki/KISS_principle Wikipedia]

==YAGNI==
"You Ain't Gonna Need It" [http://en.wikipedia.org/wiki/You_Ain't_Gonna_Need_It Wikipedia]

==DRY==
"Don't Repeat Youself" [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself Wikipedia]

This is the one where again I'm pretty puzzled by the weakness of the Wikipedia's defintion. The guy saying that DRY is only about the artifacts other than code and OAOO (Once And Only Once)is about the code, did he/she read the book carefuly?
DRY is about any ill minded repetion, read the interview with the "Pragmatic programmer" author if you don't have his book on a bookshelf to judge for yourself [http://www.artima.com/intv/dry.html]